function [alpha_ME , alpha_ij , alpha_DG_assign , LB] = MP_CVaR_333(lambda, alpha, chance )

% 两阶段鲁棒优化主问题

scenary = 10;

%% 系统参数
mpc = IEEE33;                           % 配电网参数
SB = mpc.baseMVA;                       % 基准功率,MW
VB = 12.66;                             % 基准电压,kV
IB = SB/VB;                             % 基准电流,kA
T0 = 6;                                 % 故障发生时刻
essential_load_T0 = [0.722737171 0.785660411 0.747888369 0.876237345 0.816117552 0.678217602 0.91432186 0.818438819 0.756350667 0.894745121];
ordinary_load_T0 = [0.619952976 0.751143441 0.82589798 0.777552554 0.697811513 0.791846802 0.647129924 0.659112815 0.685280112 0.588152046]; 
O_B = mpc.bus(:,1);                     % 节点集合，即点1~33
NB = length(O_B);                       % 节点数，即33
O_L = mpc.branch(:,1:2);                % 支路集合
NL = length(O_L);                       % 支路数
O_DG_candidates = (1:33)';             % DG候选节点集合，后续从中选10个
NDG = 10;                              % DG总数，其中前5为DEG，后5为PV
NPV = 5;                               % PV节点数
essential_user = [3 4 6 10 11 15 17 19 24 26 28 33];  % 重要用户负荷所在节点
ordinary_user = setdiff(O_B,essential_user);  % setdiff返回O_B中存在但essential_user中不存在的数据，不包含重复项

C_ME = 600;                              %%%% 预配置单位移动储能的成本（元/台）
C_DEG = 1000;                             %%%% 预配置单位分布式电源的成本
C_PV = 1200;                              %%%% 预配置单位分布式PV的成本

w_i = 5*ones(NB,1);                       % 单位负荷削减成本，元/kW
w_i(essential_user) = 50;               % 重要用户负荷削减成本为10元/kW
P_PV0 = [115 265 428 288 156
        97 234 417 432 210
        143 195 415 427 195
        141 242 432 293 153
        111 288 288 421 197
        132 228 288 414 146
        127 199.461 288 419 191
        144 280 342 288 216
        136 278 432 398 215
        105 244 432 298 216
        ]/1000;  % kW➡MW，还没有除以SB，不是标幺值！！
N_ME_max = 2;                           % 预布局阶段的移动储能数量上限
tan_max = 0.8;                          % 功率因数正切的最大值
tan_min = 0.4;                          % 功率因数正切的最小值
M0 = 99999;                             % 大M法的中间变量

R_ij=mpc.branch(:,3);                   % 线路电阻,pu
X_ij=mpc.branch(:,4);                   % 线路电抗,pu

P_MESS_max = 0.2;                       % 移动储能有功功率最大值,MW
Q_MESS_max = 0.17;                      % 移动储能无功功率最大值,Mvar
V_max = [1;1.1*1.1*ones(32,1)];         % 电压平方的上限,pu
V_min = [1;0.9*0.9*ones(32,1)];         % 电压平方的下限,pu
I_max = 1;                              % 电流平方的下限,pu
delta_i = zeros(NB,NL);                 % 节点i作为末端节点的支路集合
gamma_i = zeros(NB,NL);                 % 节点i作为首端节点的支路集合
% fault_branch = [1 3 7 28 35];           %%%% 故障支路
fault_branch = [1 3 7 15 19 20 23 24 28 35]; 
for k=1:NL
    delta_i(O_L(k,2),k)=1;
    gamma_i(O_L(k,1),k)=1;
end

alpha_ME = binvar(NB,1);                 % 0-1变量，表示移动储能与节点i的连接状态
alpha_DG_assign = binvar(NB,NDG);        % DG单元与节点的连接状态
alpha_ij = binvar(NL,1);                 % 支路 ij 的开断状态

xF = [alpha_ME(:); alpha_ij(:); alpha_DG_assign(:)];   % 列向量
nF = length(xF);
xF_k = zeros(nF,1); % 首次迭代的xF_k 
pais = zeros(nF,scenary); % 首次迭代的pais
obj=zeros(1,scenary);  % 储存每次计算获得的objective

it_in = 1;
while it_in <= 10
    %%  内循环主问题
    % 决策变量
    alpha_ME = binvar(NB,1);                 % 0-1变量，表示移动储能与节点i的连接状态
    alpha_DG_assign = binvar(NB,NDG);        % DG单元与节点的连接状态
    alpha_ij = binvar(NL,1);                 % 支路 ij 的开断状态
    xF = [alpha_ME(:); alpha_ij(:); alpha_DG_assign(:)];   % 列向量
    
    F_ij = sdpvar(NL,1);                    % 支路虚拟功率流
    S_vs = binvar(NDG,1);                   % 虚拟电源出力标志
    F_vs = sdpvar(NDG,1);                   % 虚拟电源出力
    P_ij = sdpvar(NL,1);                    % 线路有功功率
    Q_ij = sdpvar(NL,1);                    % 线路无功功率
    
    Constraints = [];
    
    % 每个DG单元必须分配到一个候选节点，且同一节点至多放置1个DG（对应了O_DG_candidates）
    Constraints = [Constraints , sum(alpha_DG_assign,1) == 1];
    Constraints = [Constraints , sum(alpha_DG_assign,2) <= 1];
    Constraints = [Constraints , sum(alpha_DG_assign(:)) == NDG];  %  一共10个DG
    % 式3：0
    Constraints = [Constraints , sum(alpha_ME) <= N_ME_max];
    % 式4：1
    Constraints = [Constraints , sum(alpha_ij) == NB - sum(S_vs)];
    Constraints = [Constraints , alpha_ij(fault_branch) <= 0];
    % 式5
    for k = 1:NB
        base_rhs = 1;
        % if k == 1
        %     base_rhs = 0;
        % end
        Constraints = [Constraints , delta_i(k,:)*F_ij - gamma_i(k,:)*F_ij == base_rhs - alpha_DG_assign(k,:)*F_vs];
    end
    % 式6：2
    Constraints = [Constraints , -M0*S_vs <= F_vs , F_vs <= M0*S_vs];
    % 式7
    Constraints = [Constraints , -M0*alpha_ij <= F_ij , F_ij <= M0*alpha_ij];
    Constraints = [Constraints , -M0*alpha_ij <= P_ij, P_ij <= M0*alpha_ij];  %%% 刚加的
    Constraints = [Constraints , -M0*alpha_ij <= Q_ij, Q_ij <= M0*alpha_ij];  %%% 刚加的
    
    Z = sdpvar(1,1); % 中间变量Z
    zs = sdpvar(1,scenary); 
    CVaR_eta = sdpvar(1,1); % CVaR辅助变量（实际上就是var）
    citas = sdpvar(1,scenary); 
    Constraints = [Constraints , Z >= (1-lambda)*sum(citas.*chance) + lambda*(CVaR_eta + (1/(1-alpha)*sum(chance.*zs))) ]; 
    Constraints = [Constraints , zs >= citas - CVaR_eta ];
    Constraints = [Constraints , zs >= 0 ];
    for scen = 1 : scenary
        Constraints = [Constraints, citas(scen) >= obj(scen) + sum(pais(:,scen).*(xF - xF_k)) ];
    end
    
    objective_up = sum(C_ME*alpha_ME)+sum(C_DEG*alpha_DG_assign(:,1:5),'all')+sum(C_PV*alpha_DG_assign(:,6:NDG),'all') + Z;
    
    % 设求解器
    ops = sdpsettings('verbose', 0, 'solver', 'gurobi','debug',1);
    ops.gurobi.TuneTimeLimit = 0;
    ops.gurobi.MIPGap = 0.001;                       % 收敛精度限制为0.1%
    
    sol = optimize(Constraints,objective_up,ops);
    
    if sol.problem == 0
        disp('内循环主问题求解成功');
        objective_up = value(objective_up);
        alpha_ME = value(alpha_ME); 
        disp(alpha_ME);
        alpha_ij = value(alpha_ij); 
        disp(alpha_ij);
        alpha_DG_assign = value(alpha_DG_assign); 
        disp(alpha_DG_assign);
        S_vs = value(S_vs);

        xF_k = [alpha_ME(:); alpha_ij(:); alpha_DG_assign(:)];

        % 内循环主问题获得下限
        LB_in = objective_up;
        disp(LB_in);
    else
        disp('内循环主问题无解');
        yalmiperror(sol.problem)
    end
    
    
    %% 内循环子问题

    % 内循环子问题第1层
    for scen=1:scenary
        
        % 决策变量
        P_Lsu = sdpvar(NB,1);                   % 负荷有功削减功率
        Q_Lsu = sdpvar(NB,1);                   % 负荷无功削减功率
        P_DG = sdpvar(NDG,1);                   % DG有功出力
        Q_DG = sdpvar(NDG,1);                   % DG无功出力
        V_sqr =  sdpvar(NB,1);                  % 节点电压的平方
        I_sqr = sdpvar(NL,1);                   % 支路电流的平方
        F_ij = sdpvar(NL,1);                    % 支路虚拟功率流
        F_vs = sdpvar(NDG,1);                   % 虚拟电源出力
        P_ij = sdpvar(NL,1);                    % 线路有功功率
        Q_ij = sdpvar(NL,1);                    % 线路无功功率
        P_MESS = sdpvar(NB,1);                  % 移动储能有功出力
        Q_MESS = sdpvar(NB,1);                  % 移动储能无功出力
        P_L_max = sdpvar(NB,1);                 % 负荷有功功率最大值,MW
        Q_L_max = sdpvar(NB,1);                 % 负荷无功功率最大值,MW
        P_DG_max = sdpvar(NDG,1);
        Q_DG_max = sdpvar(NDG,1); 
    
        % 约束条件
    
        Constraints = [];
    
        con_flow = cell(NB,1);
        for k = 1:NB
            base_rhs = 1;
            con_flow{k} = ( delta_i(k,:)*F_ij - gamma_i(k,:)*F_ij == base_rhs - alpha_DG_assign(k,:)*F_vs );
            Constraints = [Constraints, con_flow{k}];
        end
    
        % 式6：2
        Constraints = [Constraints , -M0*S_vs <= F_vs , F_vs <= M0*S_vs];
        
        % 式7：2
        con_F_up = ( F_ij <=  M0*alpha_ij);
        con_F_dn = (-F_ij <=  M0*alpha_ij);
        con_P_up = ( P_ij <=  M0*alpha_ij);
        con_P_dn = (-P_ij <=  M0*alpha_ij);
        con_Q_up = ( Q_ij <=  M0*alpha_ij);
        con_Q_dn = (-Q_ij <=  M0*alpha_ij);
        Constraints = [Constraints, con_F_up, con_F_dn, con_P_up, con_P_dn, con_Q_up, con_Q_dn];
        
        % 2
        Constraints = [Constraints , P_DG_max == [0.12 0.12 0.12 0.08 0.08, P_PV0(scen,:)]'];
        Constraints = [Constraints , Q_DG_max == [0.12 0.12 0.12 0.08 0.08, P_PV0(scen,:) * tan_max]'];
        
        % 66
        for h = 1:NB
            if ismember(h,essential_user)
                Constraints = [Constraints , P_L_max(h) == essential_load_T0(scen)*mpc.bus(h,3)];
                Constraints = [Constraints , Q_L_max(h) == essential_load_T0(scen)*mpc.bus(h,4)];
            else  % 即ordinary_user
                Constraints = [Constraints , P_L_max(h) == ordinary_load_T0(scen)*mpc.bus(h,3)];
                Constraints = [Constraints , Q_L_max(h) == ordinary_load_T0(scen)*mpc.bus(h,4)];
            end
        end
        
        % 式8：2
        Constraints = [Constraints , 0 <= P_Lsu , P_Lsu <= P_L_max/SB];
        
        % 式9：2
        Constraints = [Constraints , Q_Lsu(1) == 0 , Q_Lsu(2:NB) == mpc.bus(2:NB,4)./mpc.bus(2:NB,3).*P_Lsu(2:NB)];
        
        % 式10：3
        Constraints = [Constraints , 0 <= P_DG , P_DG <= P_DG_max/SB , P_DG(6:10) == [P_PV0(scen,:)/SB]'];
        
        % 式11：2
        Constraints = [Constraints , 0 <= Q_DG , Q_DG <= Q_DG_max/SB];
        
        % 式12：2
        Constraints = [Constraints , P_DG*tan_max >= Q_DG , P_DG*tan_min <= Q_DG];
        
        % 式13-14：70
        cP = P_MESS_max/SB;
        cQ = Q_MESS_max/SB;
        con_ME_P = (P_MESS <= cP*alpha_ME);
        con_ME_Q = (Q_MESS <= cQ*alpha_ME);
        Constraints = [Constraints, 0<=P_MESS, 0<=Q_MESS, con_ME_P, con_ME_Q];
        % Constraints = [Constraints , 0 <= P_MESS , P_MESS <= alpha_ME*P_MESS_max/SB , 0 <= Q_MESS , Q_MESS <= alpha_ME*Q_MESS_max/SB];
    
        con_Pbal = cell(NB,1);
        con_Qbal = cell(NB,1);
        for k = 1:NB
            con_Pbal{k} = ( alpha_DG_assign(k,:)*P_DG + P_Lsu(k) + P_MESS(k) ...
                            - P_L_max(k)/SB + delta_i(k,:)*P_ij - delta_i(k,:)*(I_sqr.*R_ij) - gamma_i(k,:)*P_ij == 0 );
        
            con_Qbal{k} = ( alpha_DG_assign(k,:)*Q_DG + Q_Lsu(k) + Q_MESS(k) ...
                            - Q_L_max(k)/SB + delta_i(k,:)*Q_ij - delta_i(k,:)*(I_sqr.*X_ij) - gamma_i(k,:)*Q_ij == 0 );
        
            Constraints = [Constraints, con_Pbal{k}, con_Qbal{k}];
        end
        
        % 式15-16：2
        m_ij=(1-alpha_ij)*M0; 
        con_V_up = ( V_sqr(O_L(:,1)) - V_sqr(O_L(:,2)) ...
                 - 2*R_ij.*P_ij - 2*X_ij.*Q_ij + (R_ij.^2+X_ij.^2).*I_sqr ...
                 - m_ij <= 0);
        con_V_dn = (-V_sqr(O_L(:,1)) + V_sqr(O_L(:,2)) ...
                     + 2*R_ij.*P_ij + 2*X_ij.*Q_ij - (R_ij.^2+X_ij.^2).*I_sqr ...
                     - m_ij <= 0);
        Constraints = [Constraints, con_V_up, con_V_dn];

        
        % 式17：2
        Constraints = [Constraints , V_max >= V_sqr , V_sqr >= V_min];
        
        % 式18：2
        Constraints = [Constraints , 0 <= I_sqr , I_sqr <= I_max];
        
        for k=1:NL
            Constraints = [Constraints, cone([2*P_ij(k) 2*Q_ij(k) I_sqr(k) - V_sqr(O_L(k,1))] , I_sqr(k) + V_sqr(O_L(k,1)))];
        end
    
        objective_dn1 = sum(w_i.*P_Lsu*1e3*SB);  
    
        % 设求解器
        ops = sdpsettings('verbose', 0, 'solver', 'mosek','debug',1);
        ops.gurobi.TuneTimeLimit = 0;
        ops.gurobi.MIPGap = 0.001;                       % 收敛精度限制为0.1%
    
        sol = optimize(Constraints,objective_dn1,ops);
    
        if sol.problem == 0
            disp(scen); disp('内循环子问题上层求解成功');
            obj(scen)=value(objective_dn1); disp(obj);
    
            mu_ME_P = dual(con_ME_P);   % NB×1  
            % disp(mu_ME_P);
            mu_ME_Q = dual(con_ME_Q);   % NB×1
            g_ME = -cP*mu_ME_P - cQ*mu_ME_Q;   % NB×1(对 alpha_ME 的次梯度)
            mu_F_up = dual(con_F_up);  mu_F_dn = dual(con_F_dn);
            mu_P_up = dual(con_P_up);  mu_P_dn = dual(con_P_dn);
            mu_Q_up = dual(con_Q_up);  mu_Q_dn = dual(con_Q_dn);
            g_ij_M = -M0*(mu_F_up + mu_F_dn + mu_P_up + mu_P_dn + mu_Q_up + mu_Q_dn);
            mu_V_up = dual(con_V_up);   % NL×1
            mu_V_dn = dual(con_V_dn);   % NL×1
            g_ij_V = +M0*(mu_V_up + mu_V_dn);
            g_ij = g_ij_M + g_ij_V;   % NL×1(对 alpha_ij 的次梯度)
            y_flow = zeros(NB,1);
            for k = 1:NB
                y_flow(k) = dual(con_flow{k});
            end
            y_Pbal = zeros(NB,1);
            y_Qbal = zeros(NB,1);
            for k = 1:NB
                y_Pbal(k) = dual(con_Pbal{k});
                y_Qbal(k) = dual(con_Qbal{k});
            end
            Fvs_val = value(F_vs);   % NDG×1
            PDG_val = value(P_DG);
            QDG_val = value(Q_DG);
            g_DG = zeros(NB,NDG);
            for k=1:NB
                g_DG(k,:) = y_flow(k)*Fvs_val' + y_Pbal(k)*PDG_val' + y_Qbal(k)*QDG_val';
            end
            g_DG = g_DG(:);   % NB*NDG × 1 (对 alpha_dg_assign 的次梯度)
    
            pais(:,scen) = [g_ME; g_ij; g_DG];   % nF×1
    
        else
            disp('内循环子问题无解');
            yalmiperror(sol.problem)
        end
    
    end


    % 内循环子问题第2层
    zs = sdpvar(1,scenary); 
    CVaR_eta = sdpvar(1,1); % CVaR辅助变量（实际上就是var）
    Constraints = [];
    Constraints = [Constraints , zs >= obj - CVaR_eta ];
    Constraints = [Constraints , zs >= 0 ];

    objective_dn2 = (1-lambda)*sum(chance.*obj) + lambda*(CVaR_eta+(1/(1-alpha))*sum(chance.*zs));

    % 设求解器
    ops = sdpsettings('verbose', 0, 'solver', 'gurobi','debug',1);
    ops.gurobi.TuneTimeLimit = 0;
    ops.gurobi.MIPGap = 0.001;                       % 收敛精度限制为0.1%

    sol = optimize(Constraints,objective_dn2,ops);

    if sol.problem == 0
        disp('内循环子问题求解成功');
        objective_dn2=value(objective_dn2); 
        % 内循环子问题获得上限
        UB_in = sum(C_ME*alpha_ME)+sum(C_DEG*alpha_DG_assign(:,1:5),'all')+sum(C_PV*alpha_DG_assign(:,6:NDG),'all') + objective_dn2;
        disp(UB_in);
    else
        disp('内循环子问题无解');
        yalmiperror(sol.problem)
    end        

    e_in = abs(UB_in-LB_in)/UB_in;  
    if e_in <= 5e-3
        break
    end

    % 内循环迭代次数+1
    it_in = it_in + 1;  

end

%% 输出结果
LB = objective_up;

end
